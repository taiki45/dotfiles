# General
## Don't cd
Work in the project root, don't cd to sub-directories to avoid re-approve tool uses.

## tmp
~/.gitignore includes `/tmp` so you can use `<project root>/tmp`.

# Golang
## Use go doc comamnd
If you use other pakcages, use `go doc` command to check package usage.

e.g. go-github library:

```
go doc github.com/google/go-github/v72/github
go doc github.com/google/go-github/v72/github.RepositoriesService
```

## Debug execution
Don't generate binaries with `go build`, use `go run` to test binary projects.

If you need to build binaries, generate under `<project_root>/tmp/`.

## Context
Don't generate context.Context temporary. Pass/recieve with arg.

## Dependency Injection
If you work on small code base projects, use public field to inject dependencies.

## Project structure
```
/cmd/           # main application
/internal/      # private code
/pkg/           # public code
```

```
go run ./cmd/foo
```

## Error Handling
- Use github.com/cockroachdb/errors
- Use `errors.WithStack()` basically
- If you can add extra information like file names, use `errors.Wrap()` to add context
- Use `return err` if the error has stack trace

### wrapcheck lint
Use wrapcheck lint. Ignore current package (e.g. `Finatext/belldog`):

```
# .golangci.yaml
    wrapcheck:
      ignore-sigs:
        - .String(
        - .JSON(
      ignore-package-globs:
        - github.com/cockroachdb/errors*
        - github.com/stretchr/testify*
        - github.com/Finatext/belldog*
```

## Interface Uses
If you work on existing project, follow the project style.

If you work on new project, define interface on user-side not supply-side.

## ラッパー構造体による機能拡張パターン

### 原則
- 既存ライブラリの型を直接継承・拡張せず、コンポジションを使用する
- `Inner`フィールドで元の機能へのアクセスを保持する
- 新しいメソッドを追加して高次の機能を提供する

### パターン
```go
type EnhancedClient struct {
    Inner *thirdparty.Client
}

func (c *EnhancedClient) HighLevelOperation() error {
    // 複数の低次操作を組み合わせた高次機能
    return c.Inner.LowLevelOperation()
}
```

### 利点
- 既存コードを変更せずに機能拡張（オープン・クローズ原則）
- テストしやすい構造
- 段階的な機能追加が可能

## コンポジションによる依存性設計

### 原則
- 具象型の埋め込み（embedding）よりも、構造体フィールドとしての保持を優先する
- 各依存関係を明示的にフィールドとして表現する
- 設定値も構造体に含めて一箇所で管理する

### パターン
```go
type Service struct {
    Client    APIClient       // 外部サービスクライアント
    Processor DataProcessor   // データ処理担当
    Store     DataStore      // 永続化担当
    Config    ServiceConfig  // 設定値
}
```

### 利点
- 依存関係が明確で理解しやすい
- 各コンポーネントの責任が分離される
- モックやスタブでのテストが容易

## ドメインモデル設計パターン

### 原則
- 外部ライブラリの型を直接ドメインモデルとして使用しない
- ドメイン固有のロジックはドメインモデルのメソッドとして実装する
- 外部型をラップしてドメインの意味を付与する

### パターン
```go
type DomainEntity struct {
    Inner      *externallib.Entity
    Properties DomainProperties
}

func (e *DomainEntity) BusinessLogicMethod() string {
    // ビジネスルールの実装
    if e.Properties.SpecialCondition {
        return e.Properties.CustomValue
    }
    return e.Inner.GetDefaultValue()
}
```

### 利点
- ビジネスロジックが集約される
- 外部ライブラリの変更に対する耐性
- ドメインの意図が明確になる

## ファクトリーパターンの活用

### 原則
- 複雑な初期化ロジックをファクトリー関数に集約する
- 環境や設定による実装の切り替えを可能にする
- エラーハンドリングを含む安全な初期化を提供する

### パターン
```go
func NewService(config Config) (*Service, error) {
    client, err := buildClient(config.ClientConfig)
    if err != nil {
        return nil, err
    }

    return &Service{
        Client: client,
        Config: config,
    }, nil
}
```

## 構造化ログの統合

### 原則
- 構造化ログを使用して機械可読なログを出力する
- 重要な操作や状態変化をログに記録する
- デバッグ情報とプロダクション情報を適切に分離する

### パターン
```go
slog.Info("operation completed",
    slog.String("entity", entity.ID),
    slog.Int("count", processedCount),
    slog.Duration("elapsed", elapsed))
```

## 実装時の指針
### 構造体設計
- 単一責任原則を守る
- 依存関係を明示的にフィールドで表現
- 設定値も構造体で管理

### パッケージ構成
- ドメインロジック、外部API、ジョブ処理などを分離
- 循環依存を避ける
- インターフェイスは使用側パッケージで定義
